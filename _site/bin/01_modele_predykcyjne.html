<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Zaawansowane techniki analityczne w biznesie</title>
    <meta charset="utf-8" />
    <meta name="author" content="© Łukasz Wawrowski" />
    <script src="libs/header-attrs-2.3/header-attrs.js"></script>
    <link rel="stylesheet" href="default.css" type="text/css" />
    <link rel="stylesheet" href="default-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Zaawansowane techniki analityczne w biznesie
## Modele predykcyjne
### © Łukasz Wawrowski

---




![](img/machine_learning.png)

https://xkcd.com/1838/

---

# Narzędzia

- [SAS Viya](https://www.sas.com/pl_pl/software/viya.html)

- [RapidMiner Studio](https://rapidminer.com/products/studio/)

- [Orange Data Mining](https://orange.biolab.si/)

- [R](https://www.r-project.org/) i [RStudio](https://rstudio.com/)

- [Python](https://www.anaconda.com/products/individual): [scikit-learn](https://scikit-learn.org/stable/index.html)

???

Jakie informacje (miary) przedstawia krzywa ROC?
Jaka jest główna idea metody grupowania k-średnich?
Wskaż różnice pomiędzy zbiorem treningowym a testowym
W jaki sposób można wykorzystać narzędzia data mining do optymalizacji kosztów w przedsiębiorstwie?

---

# Podział metod

Uczenie nadzorowane - końcowy wynik jest znany

- regresja

- klasyfikacja

Uczenie nienadzorowane - końcowy wynik nie jest znany

- grupowanie obiektów

- grupowanie cech

---

# Podział metod

![](img/wd.jpg)

---

![](img/twitter.png)

https://twitter.com/computerfact/status/974364686685794304

---

# Klasyfikacja

- binarna (binary) - tylko dwa warianty: zachorowanie, spłata kredytu

- wieloklasowa (multiclass) - typ klienta

- wieloetykietowa (multilabel) - gatunek filmu

[A visual introduction to machine learning](http://www.r2d3.us/visual-intro-to-machine-learning-part-1/)

[Model Tuning and the Bias-Variance Tradeoff](http://www.r2d3.us/visual-intro-to-machine-learning-part-2/)

---

# Podział danych

- dane uczące (treningowe) - zbiór przykładów używanych do dopasowania parametrów algorytmu

- dane testowe - niezależny od danych uczących zbiór przykładów o takim samym rozkładzie jak dane uczące

- dane walidacyjne - zbiór przykładów używanych do dopasowania hiperparametrów 

Często nazewnictwo danych testowych i walidacyjnych jest mylone.

[Wikipedia](https://en.wikipedia.org/wiki/Training%2C_validation%2C_and_test_sets)

---

# Przykład

Zbiór PVA - dane o donacjach dla weteranów. 

Organizacja weteranów poszukuje sposobu, aby lepiej pozyskiwać fundusze od darczyńców. Wysyłając upominki tylko do osób, od których szansa uzyskania donacji jest największa można w znaczący sposób ograniczyć koszty kampanii.

Podstawą jest baza zawierająca informacje o adresach do których wysłano kartkę wraz z informacją czy przełożyło się to na późniejszą donację.

[KDD Cup 1998 Data](https://kdd.ics.uci.edu/databases/kddcup98/kddcup98.html)


---

# Eksploracyjna analiza danych

Explanatory Data Analysis (EDA):

- opis

- wizualizacja

- badanie bez zakładania hipotez badawczych

---

# Przykład

Wizualizacja zmiennych: Age i Target Gift Flag

---

class: inverse

# Zadanie

Przeanalizuj rozkład cechy Median Income Region.

1. Co jest niezwykłego w rozkładzie tej cechy?

2. Jaka może być przyczyna występowania anomalii?

3. Co można zrobić w celu sprostowania sytuacji?

---

# Główne problemy

- dane niezbalansowane - w idealnym przypadku klasyfikacji, przypadków z każdej grupy powinno być tyle samo. W przeciwnym przypadku model będzie działał lepiej dla klasy większościowej. Najprostszą metodą balansowania danych jest upsampling czyli dolosowywanie obserwacji z klasy mniejszościowej, tak aby wyrównać liczebności (lub w drugę stronę - downsampling). Alternatywnie można zastosować metodę SMOTE, która generuje sztuczne obserwacje dla klasy mniejszościowej. 

- braki danych - niektóre algorytmy klasyfikacji nie obsługują braków danych. Usunięcie tych obserwacji spowodowałoby znaczne zmniejszenie próby badawczej, zatem stosuje się metody mające na celu uzupełnienie braków danych. W najprostszym przypadku braki można zastąpić średnią/medianą lub dominantą. Do bardziej zaawansowanych należy metoda najbliższych sąsiadów albo imputacja wielokrotna.

---

# Dane PVA

W oryginalnych danych wskaźnik donacji wynosił około 5%. Na potrzeby przykładu zbiór danych został zbalansowany.

---

# Algorytmy

- regresja logistyczna: wymaga spełnienia założeń

- drzewa decyzyjne: łatwa interpretacja

- metody nieparametryczne: mało efektywne dla dużych zbiorów

- metody czarnej skrzynki: SVM, sieci neuronowe, gradient

---

# Złożoność modelu

![](img/model_comp.jpg)

---

# Złożoność modelu

![](img/model_comp2.png)

---

&lt;iframe src="https://embed.polleverywhere.com/multiple_choice_polls/A780edjleaOYLda2mxC6w?controls=none&amp;short_poll=true" width="100%" height="100%" frameBorder="0"&gt;&lt;/iframe&gt;

---

# Przekształcanie cech wejściowych

- logarytm

- pierwiastek kwadratowy

- standaryzacja


---

# Drzewa decyzyjne

![](img/dt1.png)

[Źródło](https://github.com/WhyR2019/presentations/blob/master/Keynotes/Marvin_Wright_RF.pdf)

---

# Drzewa decyzyjne

![](img/dt2.png)

---

# Drzewa decyzyjne

![](img/dt3.png)

---

# Drzewa decyzyjne

![](img/dt4.png)

---

# Drzewa decyzyjne

![](img/dt5.png)

---

# Drzewa decyzyjne

![](img/dt6.png)

---

# Drzewa decyzyjne

![](img/dt7.png)

---

# SVM - maszyna wektorów nośnych

![](img/svm1.png)

---

# SVM - maszyna wektorów nośnych

![](img/svm2.png)

---

# Sieci neuronowe

![](img/nn.jpg)

---

# Boosting gradientowy

![](img/gb.png)

---

# Macierz pomyłek (confusion matrix)

![](img/cm.png)

[Źródło](https://pl.wikipedia.org/wiki/Tablica_pomy%C5%82ek)

---

# Miary

Wyniki klasyfikacji można oceniać za pomocą wielu miar:

- Dokładność (accuracy): % poprawnie zaklasyfikowanych

- Precyzja (precison): % poprawnie rozpoznanych przypadków pozytywnych TP/(TP+FP)

- Czułość (sensitivity/recall): % prawdziwie pozytywnych TP/(TP+FN)

- Swoistość (specificity): % prawdziwie negatywnych TN/(TN+FP)

- F1: średnia harmoniczna z czułości i precyzji 2TP/(2TP+FP+FN)

---

# Walidacja krzyżowa

&lt;img src="img/cv.png" height="500px"&gt;

[Źródło](https://ubc-dsci.github.io/introduction-to-datascience/)

---

# Tuning hiperparametrów

Domyślne parametry modelu nie muszą dawać najlepszych rezultatów. W celu ulepszenia klasyfikatora stosuje się metody przeszukiwania parametrów. 

- learning rate

- max depth

- number of trees

- sample rate

Można przeszukiwać całą przestrzeń paramterów (intensywne obliczeniowo) albo losowo.

---

# Objaśnianie modelu

- Ważność cech - jak bardzo model wykorzystuje daną cechę do predycji.

- Wykresy zależności cząstkowych - jak zmienia się prawdopodobieństwo klasyfikacji w zależności od predyktora.

[Explanatory Model Analysis](https://pbiecek.github.io/ema/)

[Interpretable Machine Learning](https://christophm.github.io/interpretable-ml-book/)

---

# Symulacja wyniku biznesowego

- średnia kwota donacji: 15$

- koszt wysłania upominku: 3$

---

# Krzywa LIFT

- pokazuje zysk z zastosowania badanego klasyfikatora względem klasyfikatora losowego

- interpretacja: stężenie obserwacji pozytywnych wśród pierwszych x% obserwacji np. wysłanie upominków do pierwszych 20% darczyńców 2-krotnie zwiększa szansę na pozytywną reakcję

---

# Krzywa ROC

Krzywa ROC to jeden ze sposobów wizualizacji jakości klasyfikacji, pokazujący zależności wskaźników TPR (True Positive Rate) oraz FPR (False Positive Rate).

1. obliczamy prawdopodobieństwo klasyfikacji do danej klasy

2. testujemy wiele progów prawdopodobieństwa (domyślnie 0,5)

3. dla każdego progu obliczamy macierz pomyłek

Pole pod krzywą ROC - AUC (Area under curve) jest jedną z miar jakości klasyfikacji. AUC = 1 (klasyfikator idealny), AUC = 0.5 (klasyfikator losowy), AUC &lt; 0.5 (klasyfikator gorszy od losowego)

Współczynnik Giniego: 2AUC-1. GC = 1 (klasyfikator idealny), GC = 0 (klasyfikator losowy)

[Źródło](https://algolytics.pl/tutorial-jak-ocenic-jakosc-i-poprawnosc-modeli-klasyfikacyjnych-czesc-4-krzywa-roc/)


---

class: inverse

# Zadanie

Na podstawie zbioru BIGORGANICS przeprowadź analizę predykcyjną.  

lub

Na podstawie zbioru GERMAN_CREDIT przeprowadź analizę predykcyjną.

1.  Age (numeric)
2.  Sex (text: male, female)
3.  Job (numeric: 0 - unskilled and non-resident, 1 - unskilled and resident, 2 - skilled, 3 - highly skilled)
4.  Housing (text: own, rent, or free)
5.  Saving accounts (text - little, moderate, quite rich, rich)
6.  Checking account (text, little, moderate, rich)
7.  Credit amount (numeric, in DM)
8.  Duration (numeric, in month)
9.  Purpose (text: car, furniture/equipment, radio/TV, domestic appliances.. and so on...)
10.  Risk (text: good/bad): it's our Target Variable, describes if client paid or didn't pay loan

---

class: inverse, center, middle

# Pytania?
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
