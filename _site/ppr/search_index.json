[["index.html", "Podstawy programowania R Wprowadzenie", " Podstawy programowania R ukasz Wawrowski Wprowadzenie Polecana literatura: Garret Grolemund, Hadley Wickham - R for Data Science (polska wersja) Marek Ggolewski - Programowanie w jzyku R. Analiza danych, obliczenia, symulacje. Skrypty z zaj "],["wprowadzenie-do-r.html", "1 Wprowadzenie do R 1.1 Wprowadzenie 1.2 R 1.3 RStudio 1.4 Wane informacje 1.5 Pakiety 1.6 R jako kalkulator", " 1 Wprowadzenie do R Prezentacja 1.1 Wprowadzenie GNU R to interpretowany jzyk programowania oraz rodowisko do oblicze statystycznych i wizualizacji wyników [Wikipedia 2017]. Robert A. Muenchen - The Popularity of Data Science Software 1.2 R Bazowa wersja R jest do pobrania ze strony r-project.org. 1.3 RStudio RStudio to zintegrowane rodowisko programistyczne (IDE) dla jzyka R dostpne za darmo na stronie RStudio. Z R mona take korzysta w Microsoft Visual Studio. 1.4 Wane informacje R jest wraliwy na wielko liter. Separatorem czci dziesitnej liczby jest kropka. W codziennej pracy RStudio jest wygodniejsze, jednak dugotrwae obliczenia lepiej uruchamia w trybie wsadowym w zwykym R. Katalog roboczy Wanym pojciem w R jest katalog roboczy (ang. working directory), który okrela gdzie zostan zapisane pliki, wykresy, zbiory, itp. jeli nie podamy dokadnej cieki do pliku. Katalog roboczy przypisuje si z wykorzystaniem funkcji setwd(\"cieka do katalogu\"), a jego warto mona sprawdzi funkcj getwd(). W RStudio przypisanie katalogu roboczego odbywa si w momencie utworzenia projektu. Projekt Katalog na dysku, w którym znajduj si wszystkie pliki projektu wraz z plikiem o rozszerzeniu .Rproj skojarzonym z RStudio. Korzystanie z pomocy Dostp do pomocy odnonie wybranej funkcji mona uzyska na dwa sposoby. Pierwszym z nich jest poprzedzenie nazwy funkcji w konsoli znakiem zapytania np. ?getwd lub wywoanie funkcji help na nazwie funkcji help(\"getwd\"). Drugim sposobem jest umieszczenie kursora w dowolnym miejscu nazwy funkcji i wcinicie klawisza F1. Internet - przede wszystkim stackoverflow. Komentarze Real programmers dont comment their code. If it was hard to write it should be hard to understand. Dobrze napisany kod jest czytelny bez komentarzy. W R komentarze rozpoczynaj si od symbolu #. Skrót klawiaturowy w RStudio to CTRL + SHIFT + C (do wstawiania i usuwania komentarzy). Podpowiadanie skadni RStudio ma zaimplementowan funkcj podpowiadania skadni. List moliwych funkcji i obiektów wywouj si klawiszem TAB lub CTRL + SPACJA po wpisaniu co najmniej jednej litery. Kolejne nacinicie TAB lub ENTER powoduje uzupenienie kodu o wybran funkcj lub obiekt. Wykonywanie programów Programy w R moemy tworzy jako skrypty w pliku tekstowym o rozszerzeniu .R lub wywoywa polecenia bezporednio w konsoli. Kod programu napisanego w skrypcie przekazywany jest do konsoli. Gotowo do pracy R sygnalizuje w konsoli znakiem zachty &gt;. Jeli podczas wykonywania programu w konsoli pojawi si znak + to oznacza oczekiwanie na kompletny kod - brak domknitego nawiasu, cudzysowia, itp.: &gt; getwd( + W powyszym przykadzie brakuje prawego nawiasu. Dodanie brakujcego kodu spowoduje wykonanie przekazanego polecenia. Z kolei wcinicie klawisza ESC spowoduje przerwanie wykonywanie programu i powrót do znaku zachty. Zawarto konsoli mona wyczyci stosujc kombinacj klawiszy CTRL + L. Pliki Jeli w pamici znajduj si jakie obiekty (zakadka Environment) to RStudio przy zamykaniu programu zapyta o zapisanie tych obiektów do pliku .RData. Jeeli zdecydujemy si na t propozycj to po ponownym uruchomieniu projektu obiekty znajdujce si w pliku .RData zostan automatycznie wczytane do pamici. Mona take samodzielnie tworzy pliki o rozszerzeniu .RData z wykorzystaniem funkcji save(): save(obiekt1, obiekt2, obiekt3, file = &quot;nazwa_pliku.RData&quot;) Wczytanie obiektów z takiego pliku do pamici odbywa si z zastosowaniem funkcji load(): load(&quot;nazwa_pliku.RData&quot;) 1.5 Pakiety Podstawowe moliwoci R s dosy ograniczone. Rozszerzaj je pakiety, których obecnie jest ponad 12 tysicy. Mona je przeglda wedug kategorii w CRAN Task Views lub w wygodnej wyszukiwarce METACRAN i rdrr.io. 1.6 R jako kalkulator Dziaania matematycznie w R: Operator Operacja + dodawanie - odejmowanie * mnoenie / dzielenie ^ lub ** potgowanie sqrt() pierwiastkowanie W R istnieje take staa wbudowana pi przechowujca warto liczby pi. Funkcja factorial(x) zwraca silni (znak wykrzyknika !) z podanej wartoci x, a sign(x) sprawdza znak wyraenia i zwraca odpowiednio warto -1 jeli wyraenie jest ujemne, 0 jeli jest równe 0 i 1 dla wyrae dodatnich. Funkcja exp(x) zwraca warto wyraenia \\(e^x\\), natomiast funkcja log(x) zwraca logarytm z podanej liczby. Domylnie jest to logarytm naturalny, ale mona zmieni podstaw podajc warto argumentu base. Funkcja abs(x) zwraca warto bezwzgldn (absolutn) wyraenia. wiczenie Oblicz warto wyraenia: \\(2\\cdot \\sqrt{\\pi} + log_28\\). Rozwizanie: 2*sqrt(pi)+log(8,2) ## [1] 6.544908 Zadania Oblicz warto wyrae: \\(\\frac{2^3\\cdot6^2}{(\\frac{1}{2})^2\\cdot(\\frac{4}{5})^3}\\) \\(\\sqrt[3]{\\frac{6-3.5}{2^{11}}}\\) \\(\\pi+\\sqrt{e^4}\\) \\(5! - log_{10}100\\) \\(|1-e|\\) "],["struktury-danych.html", "2 Struktury danych 2.1 Obiekty 2.2 Wektor 2.3 Macierz 2.4 Czynnik 2.5 Lista 2.6 Ramka danych", " 2 Struktury danych Prezentacja 2.1 Obiekty W R praktycznie wszystko jest obiektem. Moe to by zbiór danych, ale take wykres czy mapa. Zasadnicza rónica to klasa tych obiektów i operacje jakie mog by na nich wykonywane. Funkcje w R wymagaj jako argumentów okrelonych typów obiektów - std tak wana jak znajomo istniejcych struktur. Kady obiekt w R moemy przypisa do tzw. obiektu nazwanego. Wówczas jest przechowywany w pamici i mona si do niego odwoa. Przypisanie odbywa si za pomoc operatora &lt;-. nazwa &lt;- obiekt obiekt -&gt; nazwa Mona take przypisywa obiekty z wykorzystaniem znaku równoci =, ale nie jest to zalecane poniewa symbol ten jest uywany w innych miejscach np. do deklarowania wartoci argumentów w funkcji. W R dostpna jest funkcja assign, która take umoliwia przypisanie nazwy do obiektu: assign(&quot;nazwa&quot;, obiekt) 2.2 Wektor Wektor jest najprostszym typem danych w R. Najczciej korzysta si z trzech typów wektorów: logicznych liczbowych tekstowych Wektor tworzy si z wykorzystaniem funkcji c(). 2.2.1 Wektor wartoci logicznych Przyjmuje wartoci prawda lub fasz: c(TRUE, FALSE, FALSE) ## [1] TRUE FALSE FALSE lub w skróconej wersji: c(T, F, F) ## [1] TRUE FALSE FALSE Do sprawdzenia dugoci wektora uywa si funkcji length: length(c(T, F, F)) ## [1] 3 lub korzystajc z obiektu nazwanego: wart_log &lt;- c(T,F,F) length(wart_log) ## [1] 3 Wektory mona take utworzy poprzez replikacj okrelonej wartoci lub wektora z wykorzystaniem funkcji rep. Funkcja ta przyjmuje co najmniej dwa argumenty: obowizkowo x - wektor wejciowy oraz jeden z nastpujcych: times - liczba powtórze elementów wektora x, each - liczba powtórze elementów wektora x (wyjanienie rónicy poniej) lub length.out - oczekiwana dugo wektora wynikowego. Trzy równowane zapisy: rep(x = c(T,F), times = 3) ## [1] TRUE FALSE TRUE FALSE TRUE FALSE rep(c(T,F), times = 3) ## [1] TRUE FALSE TRUE FALSE TRUE FALSE rep(c(T,F), 3) ## [1] TRUE FALSE TRUE FALSE TRUE FALSE A tak to wyglda z argumentem each: rep(c(T,F), each = 3) ## [1] TRUE TRUE TRUE FALSE FALSE FALSE Wykorzystanie argumentu length.out: rep(c(T,F), length.out = 5) ## [1] TRUE FALSE TRUE FALSE TRUE 2.2.2 Wektor wartoci liczbowych W wektorze moemy przechowywa take liczby: c(1, 3, -5, 2.5, .6) # nie trzeba pisa zera przed uamkiem ## [1] 1.0 3.0 -5.0 2.5 0.6 Poczenie dwóch wektorów to take wektor: c(c(1,2,3), c(3.5,4,4.5)) ## [1] 1.0 2.0 3.0 3.5 4.0 4.5 Pojedyncza liczba te jest jednoelementowym wektorem: length(2) ## [1] 1 Proste cigi o rónicy równej 1 mona generowa wykorzystujc dwukropek: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 lub c(-5:-1,1:5) ## [1] -5 -4 -3 -2 -1 1 2 3 4 5 Do generowania cigów liczbowych o rónych rónicach wykorzystuje si funkcj seq, która przyjmuje nastpujce argumenty. Warto pocztkow from, warto kocow to oraz jeden z nastpujcych: by - krok lub length.out - oczekiwana dugo wektora. To samo co 1:10 seq(1, 10, 1) ## [1] 1 2 3 4 5 6 7 8 9 10 Wartoci niecakowite: seq(1, 2, 0.2) ## [1] 1.0 1.2 1.4 1.6 1.8 2.0 Wektor wartoci malejcych: seq(10, 1, by=1) # bdny zapis ## Error in seq.default(10, 1, by = 1): wrong sign in &#39;by&#39; argument seq(10, 1, by=-1) # poprawny zapis ## [1] 10 9 8 7 6 5 4 3 2 1 Tworzenie wektora w oparciu o argument length.out - funkcja sama dobiera krok: seq(1, 7, length.out = 13) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 Do generowania liczb pseudolosowych suy funkcja runif(n), która do poprawnego wywoania wymaga tylko jednego argumentu - dugoci wektora wynikowego. Domylnie losowane s liczby z przedziau \\([0;1]\\) (tak jak w funkcji los() w Excelu), mona to jednak zmieni podajc odpowiednie wartoci argumentów min i max. runif(6) ## [1] 0.2575580 0.6116951 0.3048277 0.7301113 0.8113632 0.8436331 Obserwacje mona take generowa z innych rozkadów: rnorm - rozkad normalny, rchisq - rozkad \\(\\chi^2\\), rt - rozkad t-studenta, itp. Wykaz wszystkich dostpnych w R rozkadów uzyskamy wywoujc polecenie help(\"Distributions\"). Za kadym uruchomieniem jednej z wymienionych wyej funkcji losujcych wartoci z danego rozkadu otrzymamy inne wartoci: runif(5) ## [1] 0.01749573 0.15259743 0.13177796 0.58879043 0.64654188 runif(5) ## [1] 0.20302764 0.36587143 0.25513272 0.97434381 0.01977775 Powtarzalno wyników moemy uzyska ustalajc ziarno generatora: set.seed(123) runif(5) ## [1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673 set.seed(123) runif(5) ## [1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673 2.2.3 Wektor wartoci tekstowych W wektorze moe by przechowywany tekst - wówczas poszczególne elementy zapisujemy w cudzysowie lub apostrofach: c(&quot;ala&quot;, &quot;ma&quot;, &quot;kota&quot;) ## [1] &quot;ala&quot; &quot;ma&quot; &quot;kota&quot; c(&#39;ala&#39;, &#39;ma&#39;, &#39;kota&#39;) ## [1] &quot;ala&quot; &quot;ma&quot; &quot;kota&quot; W RStudio wygodniej uywa cudzysowu, poniewa program automatycznie go zamyka. Istnieje take staa zawierajca litery alfabetu: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; 2.2.4 Przecianie wektora Jeli w wektorze pomieszamy kilka typów zmiennych to R przeksztaci poszczególne wartoci, tak aby straci jak najmniej informacji: c(TRUE, 2, 5) ## [1] 1 2 5 c(3, &quot;cztery&quot;, 5) ## [1] &quot;3&quot; &quot;cztery&quot; &quot;5&quot; W pierwszym przypadku warto TRUE zostaa przeksztacona na odpowiednik liczbowy - 1. Z kolei w drugim przykadzie podane liczby zostay przekonwertowane na tekst. 2.2.5 Operacje na wektorach Na wektorach logicznych i liczbowych mona wykonywa operacje arytmetyczne np. mnoenie: 1:10*2 ## [1] 2 4 6 8 10 12 14 16 18 20 Wektor liczbowy plus wektor liczbowy: 1:10 + c(1,2) ## [1] 2 4 4 6 6 8 8 10 10 12 Wektor liczbowy razy wektor liczbowy: 1:10 * c(1,2) ## [1] 1 4 3 8 5 12 7 16 9 20 Wektor liczbowy razy wektor logiczny: 1:10 * c(T, F) ## [1] 1 0 3 0 5 0 7 0 9 0 Dugoci obu wektorów musz by odpowiednie: 1:10 * c(T,F,T) ## Warning in 1:10 * c(T, F, T): longer object length is not a multiple of shorter ## object length ## [1] 1 0 3 4 0 6 7 0 9 10 Duszy z wektorów musi by wielokrotnoci krótszego. Si rzeczy dziaania arytmetyczne na wektorach tekstowych nie s moliwe: c(&quot;jeden&quot;, &quot;dwa&quot;, &quot;trzy&quot;, &quot;cztery&quot;) * c(T,F) ## Error in c(&quot;jeden&quot;, &quot;dwa&quot;, &quot;trzy&quot;, &quot;cztery&quot;) * c(T, F): non-numeric argument to binary operator c(&quot;jeden&quot;, &quot;dwa&quot;, &quot;trzy&quot;, &quot;cztery&quot;) + c(1,2) ## Error in c(&quot;jeden&quot;, &quot;dwa&quot;, &quot;trzy&quot;, &quot;cztery&quot;) + c(1, 2): non-numeric argument to binary operator 2.2.6 Operacje agregujce Na wektorach mona take wykonywa operacje agregujce: Funkcja Dziaanie mean() rednia elementów sum() suma elementów prod() iloczyn elementów var() wariancja elementów sd() odchylenie standardowe elementów median() mediana elementów quantile() kwantyl danego rzdu min() minimum max() maksimum Obliczenie skonoci i kurtozy jest moliwe po zainstalowaniu pakietu e1071. Wówczas mamy dostp do funkcji: Funkcja Dziaanie skewness() skono elementów kurtosis() kurtoza elementów Suma wektora numerycznego: sum(1:10) ## [1] 55 Suma i rednia wektora logicznego: sum(c(T, F, F, T)) ## [1] 2 mean(c(T, F, F, T)) ## [1] 0.5 Korzystanie z funkcji pochodzcych z pakietów zewntrznych wymaga wskazania skd pochodzi dana funkcja. Mona to zrobi na dwa sposoby: funkcj library(pakiet) - wówczas wszystkie funkcje z tego pakietu s wczytywane do pamici i mona do nich siga bezporednio lub wskazujc przed nazw funkcji z jakiego pakietu pochodzi. Wczytanie pakietu: library(e1071) skewness(c(1,2,3,4,5,7,9,11,13)) ## [1] 0.3451259 lub równowanie: e1071::skewness(c(1,2,3,4,5,7,9,11,13)) ## [1] 0.3451259 Podsumowanie rozkadu wektora mona take uzyska z wykorzystaniem funkcji summary(x): summary(1:10) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 3.25 5.50 5.50 7.75 10.00 Dziaa take na wektorach tekstowych: summary(c(&quot;jeden&quot;, &quot;dwa&quot;, &quot;trzy&quot;, &quot;cztery&quot;)) ## Length Class Mode ## 4 character character 2.2.7 Sprawdzanie typu wektora Do okrelenia typu wektora suy funkcja typeof, class lub mode. typeof(wart_log) ## [1] &quot;logical&quot; Sprawdzenie czy obiekt jest danego typu odbywa si z wykorzystaniem dedykowanych funkcji z przyrostkiem is. is.logical(wart_log) ## [1] TRUE is.character(wart_log) ## [1] FALSE 2.2.8 Rzutowanie wektorów Czasami jako np. argument funkcji bdzie wymagany inny typ wektora anieli aktualnie posiadany w pamici. Mona wówczas spróbowa przeksztaci taki wektor z wykorzystaniem funkcji rozpoczynajcej si od as.: typeof(wart_log) ## [1] &quot;logical&quot; as.numeric(wart_log) ## [1] 1 0 0 typeof(as.numeric(wart_log)) ## [1] &quot;double&quot; 2.2.9 Indeksowanie wektorów Aby uzyska dostp do czci wektora korzysta si z indeksatora w postaci nawiasów kwadratowych. Utworzymy nowy wektor zawierajcy liczby cakowite od 10 do 20: wart_10_20 &lt;- seq(10,20) wart_10_20 ## [1] 10 11 12 13 14 15 16 17 18 19 20 a nastpnie wybieramy trzeci obserwacj: wart_10_20[3] ## [1] 12 Moemy take odwoa si do wikszego zakresu: wart_10_20[3:5] ## [1] 12 13 14 I wybranych elementów: wart_10_20[c(1,3,5)] ## [1] 10 12 14 W ten sposób mona take modyfikowa odpowiednie elementy wektora: wart_10_20[7] &lt;- 90 Wybór obserwacji wikszych od 15: wart_10_20[wart_10_20&gt;15] ## [1] 90 17 18 19 20 Z kolei nastpujcy zapis zwróci nam wektor wartoci logicznych: wart_10_20 &gt; 15 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE 2.2.10 Wartoci nieliczbowe Brak danych w R jest przedstawiany jako warto NA (ang. not available) i moe powodowa trudnoci z wywoywaniem niektórych funkcji: v_na &lt;- c(1,2,1,NA,1) v_na ## [1] 1 2 1 NA 1 sum(v_na) ## [1] NA W zwizku z tym wikszo funkcji ma zaimplementowany dodatkowy argument sucy do obsugi tego typu wartoci, który najczciej nie uwzgldnia tych wartoci w obliczeniach: sum(v_na, na.rm = TRUE) ## [1] 5 Oprócz braku danych podczas oblicze moemy natrafi na wartoci nieokrelone NaN (ang. not a number) oraz nieskoczone Inf (ang. infinity). 0/0 ## [1] NaN 1/0 ## [1] Inf sqrt(-10) ## Warning in sqrt(-10): NaNs produced ## [1] NaN W R istnieje take warto NULL, która jest podstawowym typem danych a nie wartoci. NULL mona traktowa jako odpowiednik zbioru pustego. Jest stosowany np. w funkcjach, które niczego nie zwracaj. v_null &lt;- c(1,2,1,NULL,1) v_null ## [1] 1 2 1 1 sum(v_null) ## [1] 5 2.2.11 Zadania Ile wynosi suma elementów wikszych od 10 dla nastpujcych liczb: 12, 5, 20, 18, 8.5, 10, 4, 101, -2? Z wykorzystaniem funkcji seq i na podstawie wektora  dokonaj przeksztacenia tworzc nastpujcy wektor: 2 0 0 4 0 0 6 0 0 8 0 0. Dane s dwa wektory - a: 2, 3, 7, 8, 2, b: 9, 1, 2, 0, 2. Jakiego typu bdzie wektor bdcy wynikiem dziaania a&lt;=b? Uzupenij wektor letters o polskie litery diakrytyzowane. Jak dugo ma nowo utworzony wektor? Wylosuj z rozkadu normalnego 1000 obserwacji z ziarnem równym 76. Ile wynosi kurtoza tych wartoci? 2.3 Macierz Macierze s wykorzystywane w R do przechowywania np. odlegoci pomidzy punktami czy wskazywania ssiedztwa obszarów geograficznych. Do tworzenia macierzy suy funkcja matrix: m &lt;- matrix(1:6, nrow = 2, ncol=3) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Z wykorzystaniem wybranych funkcji mona sprawdzi wymiary macierzy, liczb wierszy oraz kolumn: dim(m) ## [1] 2 3 ncol(m) ## [1] 3 nrow(m) ## [1] 2 Macierz moe take zawiera tekst: matrix(letters[1:9], nrow=3) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;d&quot; &quot;g&quot; ## [2,] &quot;b&quot; &quot;e&quot; &quot;h&quot; ## [3,] &quot;c&quot; &quot;f&quot; &quot;i&quot; Domylnie macierz ukadana jest kolumnami. Aby to zmieni naley doda argument byrow=TRUE: matrix(letters[1:9], nrow=3, byrow=TRUE) ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; ## [3,] &quot;g&quot; &quot;h&quot; &quot;i&quot; Jeli liczba elementów wejciowych jest mniejsza iloczyn podanej liczby kolumn i wierszy to w brakujce miejsce wstawiane s elementy z pocztku wektora wejciowego: matrix(letters[1:7], nrow=3, byrow=TRUE) ## Warning in matrix(letters[1:7], nrow = 3, byrow = TRUE): data length [7] is not ## a sub-multiple or multiple of the number of rows [3] ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; ## [3,] &quot;g&quot; &quot;a&quot; &quot;b&quot; Z kolei macierz diagnonaln posiadajc elementy niezerowe wycznie na przektnej tworzy si z wykorzystaniem funkcji diag. Macierz jednostkowa o wymiarach \\(4 \\times 4\\): diag(4) ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 1 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 1 Macierz diagonalna o wartociach 5 na przektnej i wymiarach \\(3 \\times 3\\) diag(5, nrow=3, ncol=3) ## [,1] [,2] [,3] ## [1,] 5 0 0 ## [2,] 0 5 0 ## [3,] 0 0 5 Funkcja diag umoliwia take ekstrakcj przektnej z istniejcej ju macierzy: diag(matrix(letters[1:9], nrow=3)) ## [1] &quot;a&quot; &quot;e&quot; &quot;i&quot; 2.3.1 czenie macierzy Z wykorzystaniem funkcji rbind i cbind mona odpowiednio czy obiekty wierszami (ang. row bind) lub kolumnami (ang. col bind): rbind(m, c(99, 88, 77)) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## [3,] 99 88 77 cbind(m, matrix(101:104, nrow=2)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 101 103 ## [2,] 2 4 6 102 104 2.3.2 Indeksowanie macierzy Dostp do poszczególnych elementów macierzy odbywa si z wykorzystaniem nawiasów kwadratowych, ale mona poda dwie warto - obiekt[wiersz,kolumna]: m[2,1] # drugi wiersz, pierwsza kolumna ## [1] 2 m[2,] # tylko drugi wiersz ## [1] 2 4 6 m[,1] # tylko pierwsza kolumna ## [1] 1 2 m[,] # wszystkie obserwacje ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 m[] # wszystkie obserwacje ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 W ten sposób mona dokona modyfikacji konkretnych elementów macierzy: m[2,1] &lt;- 77 m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 77 4 6 2.3.3 Operacje na macierzach Na macierzach mona wywoa szereg operacji: Operator/funkcja Dziaanie a %*% b mnoenie macierzy a i b t(a) transpozycja macierzy a det(a) wyznacznik macierzy a solve(a) macierz odwrotna z a solve(a, b) rozwizanie ukadu a*x=b Rozwamy dwie macierze: a &lt;- matrix(c(2, 3, 4, 2, 1, 2, 1, 3, 2), nrow = 3) b &lt;- matrix(6:1, ncol=2) a;b ## [,1] [,2] [,3] ## [1,] 2 2 1 ## [2,] 3 1 3 ## [3,] 4 2 2 ## [,1] [,2] ## [1,] 6 3 ## [2,] 5 2 ## [3,] 4 1 Aby przeprowadzi mnoenie macierzy a i b, liczba kolumn macierzy a musi by równa liczbie wierszy w macierzy b. Z kolei rozmiar macierzy wyjciowej to liczba wierszy macierzy a i liczba kolumn macierzy b. a %*% b ## [,1] [,2] ## [1,] 26 11 ## [2,] 35 14 ## [3,] 42 18 Transpozycja macierzy b: t(b) ## [,1] [,2] [,3] ## [1,] 6 5 4 ## [2,] 3 2 1 Wyznacznik macierzy a: det(a) ## [1] 6 Macierz odwrotna do macierzy a: solve(a) ## [,1] [,2] [,3] ## [1,] -0.6666667 -0.3333333 0.8333333 ## [2,] 1.0000000 0.0000000 -0.5000000 ## [3,] 0.3333333 0.6666667 -0.6666667 Wyznaczenie macierzy x w równaniu a*x=b: solve(a,b) ## [,1] [,2] ## [1,] -2.333333 -1.833333 ## [2,] 4.000000 2.500000 ## [3,] 2.666667 1.666667 a %*% solve(a,b) ## [,1] [,2] ## [1,] 6 3 ## [2,] 5 2 ## [3,] 4 1 b ## [,1] [,2] ## [1,] 6 3 ## [2,] 5 2 ## [3,] 4 1 2.3.4 Zadanie Co powstanie po przemnoeniu macierzy przez jej macierz odwrotn? Estymator parametrów beta w metodzie najmniejszych kwadratów jest dany wzorem: \\[b=(X&#39;X)^{-1}X&#39;y\\] Zmienna \\(x_1\\) przyjmuje wartoci 2,4,1,6,9,3,2,9,10,7, zmienna \\(x_2\\) 1.5,0.2,0.1,2,3.1,1.2,0.4,2.9,2.5,1.9, a zmienna \\(x_0\\) to wektor jedynek. Te trzy zmienne tworz macierz \\(X\\). Z kolei wartoci zmiennej \\(y\\) s nastpujce 12,15,10,19,26,13,13,21,29,18. Wyznacz warto \\(b\\). zad1 &lt;- matrix(1:4, nrow=2) solve(zad1) ## [,1] [,2] ## [1,] -2 1.5 ## [2,] 1 -0.5 zad1 %*% solve(zad1) ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 2.4 Czynnik Czynnik (ang. factor) suy do przechowywania danych jakociowych o mao licznej liczbie kategorii, mierzonych na skali nominalnej i porzdkowej. Rozwamy informacje o wyksztaceniu: wyk &lt;- rep(c(&quot;podstawowe&quot;, &quot;rednie&quot;, &quot;wysze&quot;), c(5,3,2)) wyk ## [1] &quot;podstawowe&quot; &quot;podstawowe&quot; &quot;podstawowe&quot; &quot;podstawowe&quot; &quot;podstawowe&quot; ## [6] &quot;rednie&quot; &quot;rednie&quot; &quot;rednie&quot; &quot;wysze&quot; &quot;wysze&quot; i dokonajmy transformacji na czynnik: wyk_f &lt;- factor(wyk) wyk_f ## [1] podstawowe podstawowe podstawowe podstawowe podstawowe rednie ## [7] rednie rednie wysze wysze ## Levels: podstawowe rednie wysze Funkcja summary() wywoana na czynniku zwraca wynik innego typu anieli na wektorze tekstowym: summary(wyk) ## Length Class Mode ## 10 character character summary(wyk_f) ## podstawowe rednie wysze ## 5 3 2 Jeli chcemy zaakcentowa fakt, e zmienne s mierzone na skali porzdkowej dodajemy argument ordered=TRUE: wyk_of &lt;- factor(wyk, ordered = TRUE) wyk_of ## [1] podstawowe podstawowe podstawowe podstawowe podstawowe rednie ## [7] rednie rednie wysze wysze ## Levels: podstawowe &lt; rednie &lt; wysze W atwy sposób moemy edytowa etykiety: levels(wyk_of) &lt;- c(&quot;pod.&quot;, &quot;r.&quot;, &quot;wy.&quot;) wyk_of ## [1] pod. pod. pod. pod. pod. r. r. r. wy. wy. ## Levels: pod. &lt; r. &lt; wy. Czynniki maj szczególne znaczenie w przypadku tworzenia wykresów, gdy chcemy okreli porzdek wywietlania. 2.5 Lista Listy to cigi zoone z elementów o dowolnych typach. Mog przyda si w szczególnoci przy budowaniu funkcji, które zwracaj tylko jedn warto. Wówczas dane rónego typu mog by zawarte w takiej licie. Tworzenie prostej listy: l &lt;- list(TRUE, c(1,2,3,4), &quot;element tekstowy&quot;) l ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] 1 2 3 4 ## ## [[3]] ## [1] &quot;element tekstowy&quot; Ju na pierwszy rzut oka wida bardziej zoon struktur listy. W zwizku z tym odwoywanie do poszczególnych elementów bdzie troch si róni od wektorów czy macierzy. l[2] # druga lista ## [[1]] ## [1] 1 2 3 4 l[[2]] # zawarto listy ## [1] 1 2 3 4 l[[2]][3] # trzeci element wektora drugiej listy ## [1] 3 List mona take rozwin do wektora z wykorzystaniem funkcji unlist: unlist(l) ## [1] &quot;TRUE&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [5] &quot;4&quot; &quot;element tekstowy&quot; Poszczególne elementy listy mona nazwa: ln &lt;- list(log=TRUE, num=c(1,2,3,4), tekst=&quot;element tekstowy&quot;) ln ## $log ## [1] TRUE ## ## $num ## [1] 1 2 3 4 ## ## $tekst ## [1] &quot;element tekstowy&quot; Wówczas mona uzyska do nich dostp poprzez symbol $ i podan nazw: ln$num ## [1] 1 2 3 4 ln[[2]] # normalne indeksowanie nadal dziaa ## [1] 1 2 3 4 ln$num[2] ## [1] 2 2.6 Ramka danych Ramka danych to tabela, która przypomina t z Excela zawierajca dane o rónych typach. Tworzona za pomoc funkcji data.frame: df &lt;- data.frame(plec=c(&quot;m&quot;, &quot;k&quot;, &quot;k&quot;, &quot;m&quot;, &quot;k&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;), wzrost=c(173, 170, 163, 178, 169, 180, 175, NA), pali=c(T, F, F, F, T, F, NA, T)) W RStudio po wybraniu tego obiektu w zakadce Environment pojawia si przyjazne okno do przegldania oraz pogldowego filtrowania i sortowania danych ze zbioru. Moemy zobaczy podsumowanie caego zbioru wywoujc na nim funkcj summary(): summary(df) ## plec wzrost pali ## Length:8 Min. :163.0 Mode :logical ## Class :character 1st Qu.:169.5 FALSE:4 ## Mode :character Median :173.0 TRUE :3 ## Mean :172.6 NA&#39;s :1 ## 3rd Qu.:176.5 ## Max. :180.0 ## NA&#39;s :1 Ramki danych mona indeksowa w taki sam sposób jak macierze lub z wykorzystaniem operatora $: df[,2] # druga kolumna ## [1] 173 170 163 178 169 180 175 NA df$wzrost # kolumna wzrost ## [1] 173 170 163 178 169 180 175 NA df[,c(&quot;plec&quot;, &quot;pali&quot;)] ## plec pali ## 1 m TRUE ## 2 k FALSE ## 3 k FALSE ## 4 m FALSE ## 5 k TRUE ## 6 m FALSE ## 7 m NA ## 8 m TRUE Z kolei do wyboru obserwacji mona wykorzysta warunek: df[df$plec==&quot;m&quot;,] ## plec wzrost pali ## 1 m 173 TRUE ## 4 m 178 FALSE ## 6 m 180 FALSE ## 7 m 175 NA ## 8 m NA TRUE Wyodrbnienie informacji o wzrocie tylko dla kobiet i wyznaczenie redniej: wzrost_k &lt;- df$wzrost[df$plec == &quot;k&quot;] wzrost_k ## [1] 170 163 169 mean(wzrost_k) ## [1] 167.3333 Widzimy, e dla mczyzn nie udao si ustali wszystkich informacji i jeden z nich nie ma podanego wzrostu, a dla drugiego brakuje informacji o paleniu papierosów. Moemy usun braki danych w kolumnach korzystajc z funkcji complete.cases(): df[complete.cases(df$wzrost),] # tylko zmienna wzrost ## plec wzrost pali ## 1 m 173 TRUE ## 2 k 170 FALSE ## 3 k 163 FALSE ## 4 m 178 FALSE ## 5 k 169 TRUE ## 6 m 180 FALSE ## 7 m 175 NA df[complete.cases(df),] # wszystkie zmienne ## plec wzrost pali ## 1 m 173 TRUE ## 2 k 170 FALSE ## 3 k 163 FALSE ## 4 m 178 FALSE ## 5 k 169 TRUE ## 6 m 180 FALSE Zbiory danych przechowywane s take w R i pochodz z rónych pakietów. Wywoujc funkcj data(\"zbior\") adujemy dany zbiór do pamici. Do szybkiego podgldu zebranych danych suy funkcja head(), która domylnie wywietla 6 pierwszych obserwacji ze zbioru: data(&quot;iris&quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa 2.6.1 Zadania Zaaduj do pamici zbiór o nazwie ChickWeight. Ile razy jedzenie otrzyma kurczak o numerze 15? Ile wynosi mediana wagi kurczaka o numerze 35? Ile rednio wayy kurczaki na diecie nr 1, a ile na diecie nr 2? "],["przetwarzanie-danych.html", "3 Przetwarzanie danych 3.1 Wprowadzenie - pakiet tidyverse 3.2 Import danych 3.3 Filtrowanie 3.4 Wybieranie kolumn 3.5 Tworzenie nowych zmiennych 3.6 Zmiana nazwy zmiennej 3.7 Podsumowanie danych 3.8 Grupowanie 3.9 Sortowanie 3.10 czenie zbiorów 3.11 Szeroka i wska reprezentacja danych 3.12 Eksport danych 3.13 Zadania 3.14 Case study", " 3 Przetwarzanie danych Prezentacja - wczytywanie danych Prezentacja - przetwarzanie 3.1 Wprowadzenie - pakiet tidyverse Pakiet tidyverse to zestaw pakietów do kompleksowego przetwarzania i wizualizacji danych. aduje nastpujce pakiety: ggplot2 - tworzenie wykresów, dplyr - przetwarzanie danych, tidyr - zmiana reprezentacji danych, readr - wczytywanie danych tekstowych, purrr - programowanie funkcyjne tibble - sposób przechowywania danych, stringr - przetwarzanie tekstów, forcats - przetwarzanie faktorów Manifest tidyverse ustala nastpujce zasady: powtórne uycie istniejcych struktur danych, tworzenie czytelnych kodów z operatorem pipe %&gt;% (ang. rura, przewód, cznik). Wobec tego zaadujmy pakiet tidyverse: library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.1 -- ## v ggplot2 3.3.5 v purrr 0.3.4 ## v tibble 3.1.6 v dplyr 1.0.7 ## v tidyr 1.1.4 v stringr 1.4.0 ## v readr 2.1.1 v forcats 0.5.1 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() W konsoli pojawi si informacja o wersji zaadowanych pakietów oraz o konfliktach wystpujcych pomidzy pakietami. Konflikty te wynikaj z takich samych nazw funkcji w rónych pakietach. Kolejno wczytywania pakietów ma znaczenie - kolejny pakiet przykryje funkcje z wczeniej wczytanego. Wywoanie przykrytej funkcji jest moliwe poprzez zapis nazwa_pakietu::nazwa_funkcji. Korzystanie z pakietu i zasad tidyverse to duo bardziej czytelny kod w porównaniu do wbudowanych funkcji. Poniej przedstawiony jest przykad przetwarzania danych polegajcy na filtrowaniu, wyborze kolumn oraz utworzeniu nowej zmiennej. data(&quot;ChickWeight&quot;) # bez pakietu tidyverse chick_15 &lt;- ChickWeight[ChickWeight$Chick==&quot;15&quot;,] chick_15 &lt;- chick_15[c(&quot;weight&quot;, &quot;Time&quot;, &quot;Diet&quot;),] chick_15$weight_kg &lt;- chick_15$weight/1000 # z pakietem tidyverse chick_15 &lt;- ChickWeight %&gt;% filter(Chick==&quot;15&quot;) %&gt;% select(-Chick) %&gt;% mutate(weight_kg=weight/1000) Rozwizanie z wykorzystaniem wbudowanych funkcji to 133 znaki, natomiast wykorzystanie tidyverse to 30% oszczdno miejsca i tylko 92 znaki. 3.2 Import danych Wczytywanie danych do R jest moliwe z wielu rónych róde. Funkcje, które to umoliwiaj zwykle maj nazw rozpoczynajc si od read. Bdziemy korzysta z nastpujcych zbiorów danych: movies - plik tekstowy zawierajcy informacje o filmach, bank - plik excel zawierajcy dane dot. kampanii marketingowej banku, opis zmiennych, rossmann - plik excel zawierajcy dane ze sklepów Rossmann, lotto - plik tekstowy zawierajcy dane z losowa Lotto. 3.2.1 Pliki CSV Do wczytywania plików csv mona wykorzysta wbudowan funkcj read.csv() lub t pochodzc z pakietu readr - read_csv(). W obu przypadkach wynik wczytania bdzie podobny. movies &lt;- read.csv(&quot;data/movies.csv&quot;) movies2 &lt;- read_csv(&quot;data/movies.csv&quot;) ## Rows: 2961 Columns: 11 ## -- Column specification -------------------------------------------------------- ## Delimiter: &quot;,&quot; ## chr (3): title, genre, director ## dbl (8): year, duration, gross, budget, cast_facebook_likes, votes, reviews,... ## ## i Use `spec()` to retrieve the full column specification for this data. ## i Specify the column types or set `show_col_types = FALSE` to quiet this message. Jeli nas plik ma nietypow struktur to w funkcji read.csv() moemy okreli dodatkowe argumenty informujc o nazwach kolumn obecnych w pliku (header =), separatorze kolumn (sep =) lub separatorze miejsc dziesitnych (dec =) movies &lt;- read.csv(file = &quot;data/movies.csv&quot;, header = T, sep=&quot;,&quot;, dec=&quot;.&quot;) 3.2.2 Pliki excel Do wczytywania plików z Excela niezbdny jest dodatkowy pakiet readxl. W funkcji read_xlsx() podajemy jako argument nazw pliku. Moemy take doda nazw lub numer arkusza w argumencie (sheet =) oraz zakres komórek jako warto argumentu range =. library(readxl) bank &lt;- read_xlsx(&quot;data/bank.xlsx&quot;) # bank &lt;- read_xlsx(&quot;data/bank.xlsx&quot;, sheet = &quot;dane&quot;) # bank &lt;- read_xlsx(&quot;data/bank.xlsx&quot;, sheet = 1) bank_a1i30 &lt;- read_xlsx(&quot;data/bank.xlsx&quot;, range = &quot;A1:I30&quot;) rossmann &lt;- read_xlsx(&quot;data/rossmann.xlsx&quot;) 3.2.3 Pliki tekstowe Z kolei do wczytywania plików tekstowych wykorzystuje si funkcj read.table(). Wczytywany plik nie musi by zlokalizowany na dysku twardym - moe to by link internetowy. lotto &lt;- read.table(&quot;http://www.mbnet.com.pl/dl.txt&quot;) names(lotto) &lt;- c(&quot;lp&quot;, &quot;data&quot;, &quot;numery&quot;) 3.3 Filtrowanie Do przetwarzania danych su funkcje z pakietu dplyr. Wikszo z nich jako pierwszy argument przyjmuje przetwarzany zbiór danych, ale mona tego unikn wykorzystujc symbole %&gt;%. Filtrowanie polega na wybraniu obserwacji, które speniaj okrelony warunek lub warunki. Ze zbioru movies wybierzmy wszystkie komedie: komedie &lt;- filter(movies, genre==&quot;Comedy&quot;) lub alternatywnie: komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) Po zmiennej, która jest filtrowana musimy poda operator porównania czyli podwójny znak równoci ==. Jeli chcemy filtrowa po wikszej liczbie zmiennych to kolejne warunki dodajemy po przecinku: komedie_2012 &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;, year==2012) Wówczas oba warunki musz zosta spenione czyli pomidzy nimi zachodzi relacja i. Równowany zapis jest nastpujcy: komedie_2012 &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot; &amp; year==2012) Pomidzy warunkami moe take zachodzi relacja lub. Wybieramy filmy, które s komediami lub miay swoj premier w 2012 roku. komedie_l_2012 &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot; | year==2012) Moliwy jest take wybór wielu kryteriów filtrowania poprzez operator %in%: komedie_familijne &lt;- movies %&gt;% filter(genre %in% c(&quot;Comedy&quot;, &quot;Family&quot;)) movies_2000_2010 &lt;- movies %&gt;% filter(year %in% 2000:2010) 3.4 Wybieranie kolumn Do wyboru kolumn suy funkcja select(). Zmodyfikujemy wczeniej utworzony zbiór komedie: komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(title, year, duration, budget, rating) Ten sam kod moemy zapisa zagniedajc funkcje, ale traci on w ten sposób na czytelnoci: komedie &lt;- select(filter(movies, genre==&quot;Comedy&quot;), title, year, duration, budget, rating) Moemy take wskaza, które zmienne nie maj znale si w zbiorze wynikowym: komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-genre) Natomiast jeli zmiennych jest wicej to musimy jest umieci w wektorze, eby nie pisa przed kad zmienn znaku minus: komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-genre, -director, -gross, -budget) komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-c(genre, director, gross, budget)) Z wykorzystaniem znaku dwukropka moemy take wskazywa zakresy zmiennych: komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-genre, -c(gross:reviews)) 3.5 Tworzenie nowych zmiennych Do utworzenia nowej zmiennej wykorzystuje si funkcj mutate(). Utwórzmy w naszym zbiorze now zmienn, która bdzie zawieraa czas trwania filmu w godzinach: komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-genre, -c(gross:reviews)) %&gt;% mutate(dur_hour = duration/60) Rozsdnie bdzie zaokrgli otrzyman warto do jednego miejsca po przecinku - suy do tego funkcja round(): komedie &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-genre, -c(gross:reviews)) %&gt;% mutate(dur_hour = round(duration/60,1)) Z kolei funkcja transmute() tworzy zbiór w którym jest tylko nowo utworzona kolumna: komedie_t &lt;- movies %&gt;% filter(genre==&quot;Comedy&quot;) %&gt;% select(-genre, -c(gross:reviews)) %&gt;% transmute(dur_hour = round(duration/60,1)) 3.6 Zmiana nazwy zmiennej Do zmiany nazw zmiennych suy funkcja rename(). Najpierw podajemy nazw nowej zmiennej, a po znaku równoci star nazw: bank &lt;- bank %&gt;% rename(karta=kredyt) Zmiany nazwy mona take dokona z wykorzystaniem funkcji select: bank_nowy &lt;- bank %&gt;% select(lokata=wynik) W takim przypadku trzeba jednak pamita o wypisaniu wszystkich zmiennych, które maj si znale w zbiorze wynikowym. 3.7 Podsumowanie danych Funkcja summarise() suy do podsumowa danych w formie zagregowanej: bank %&gt;% summarise(saldo_srednia=mean(saldo), saldo_mediana=median(saldo)) ## # A tibble: 1 x 2 ## saldo_srednia saldo_mediana ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1362. 448 Podsumowanie danych ma najwicej sensu w poczniu z funkcj grupujc. 3.8 Grupowanie Do grupowania obserwacji suy funkcja group_by(). Zobaczmy jak wygldaj statystyki salda w poszczególnych grupach wyksztacenia: bank %&gt;% group_by(wykszt) %&gt;% summarise(saldo_srednia=mean(saldo), saldo_mediana=median(saldo)) ## # A tibble: 4 x 3 ## wykszt saldo_srednia saldo_mediana ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 podstawowe 1251. 403 ## 2 srednie 1155. 392 ## 3 wyzsze 1758. 577 ## 4 &lt;NA&gt; 1527. 568 Po przecinku w funkcji group_by() mona wskaza kolejne zmienne grupujce: bank %&gt;% group_by(wykszt, hipoteka) %&gt;% summarise(saldo_srednia=mean(saldo), saldo_mediana=median(saldo)) ## `summarise()` has grouped output by &#39;wykszt&#39;. You can override using the `.groups` argument. ## # A tibble: 8 x 4 ## # Groups: wykszt [4] ## wykszt hipoteka saldo_srednia saldo_mediana ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 podstawowe nie 1571. 521 ## 2 podstawowe tak 1008. 344. ## 3 srednie nie 1340. 416. ## 4 srednie tak 1034. 380 ## 5 wyzsze nie 1919. 618 ## 6 wyzsze tak 1584. 543 ## 7 &lt;NA&gt; nie 1780. 679 ## 8 &lt;NA&gt; tak 1207. 442 Przydatna jest take funkcja n(), która nie przyjmuje adnego argumentu i zwraca liczebno zbioru bd grupy. bank %&gt;% group_by(wykszt) %&gt;% summarise(liczebnosc=n(), saldo_srednia=mean(saldo), saldo_mediana=median(saldo)) ## # A tibble: 4 x 4 ## wykszt liczebnosc saldo_srednia saldo_mediana ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 podstawowe 6851 1251. 403 ## 2 srednie 23202 1155. 392 ## 3 wyzsze 13301 1758. 577 ## 4 &lt;NA&gt; 1857 1527. 568 Jeeli chcemy tylko wyznaczy liczebnoci grup to moemy skorzysta z funkcji count(): bank %&gt;% group_by(wykszt) %&gt;% count() ## # A tibble: 4 x 2 ## # Groups: wykszt [4] ## wykszt n ## &lt;chr&gt; &lt;int&gt; ## 1 podstawowe 6851 ## 2 srednie 23202 ## 3 wyzsze 13301 ## 4 &lt;NA&gt; 1857 Jedn z kategorii zmiennej wyksztacenie jest brak danych (NA). Zamienimy t warto na kategori nieustalone z wykorzystaniem funkcji mutate() oraz if_else(). Funkcja if_else() przyjmuje trzy argumenty - pierwszy (condition =) to warunek, który jest weryfikowany, nastpnie podajemy warto, która ma by wprowadzona w przypadku spenienia warunku (true =), a na kocu warto dla niespenionego warunku (false =). Jest to odpowiednik funkcji JEELI z Excela. W omawianym przykadzie warunkiem jest sprawdzenie czy wartoci zmiennej wykszt s równe NA. Jeli tak to na ich miejsce wprowadzany jest tekst nieustalone, a w przeciwnym przypadku pozostaje oryginalna warto. bank %&gt;% mutate(wykszt=if_else(is.na(wykszt), &quot;nieustalone&quot;, wykszt)) %&gt;% group_by(wykszt) %&gt;% count() ## # A tibble: 4 x 2 ## # Groups: wykszt [4] ## wykszt n ## &lt;chr&gt; &lt;int&gt; ## 1 nieustalone 1857 ## 2 podstawowe 6851 ## 3 srednie 23202 ## 4 wyzsze 13301 3.9 Sortowanie Sortowanie jest moliwe z wykorzystaniem funkcji arrange(). Jako argument podajemy zmienn wedug, której chcemy posortowa zbiór. Domylne zbiór sortowany jest rosnco - od wartoci najmniejszych do najwikszych: bank_sort &lt;- bank %&gt;% arrange(saldo) Zmiana kierunku sortowania jest moliwa po zastosowaniu funkcji desc(): bank_sort &lt;- bank %&gt;% arrange(desc(saldo)) Sortowanie moemy take zastosowa do wyników podsumowania danych: bank %&gt;% group_by(wykszt) %&gt;% summarise(liczebnosc=n(), saldo_srednia=mean(saldo), saldo_mediana=median(saldo)) %&gt;% arrange(saldo_srednia) ## # A tibble: 4 x 4 ## wykszt liczebnosc saldo_srednia saldo_mediana ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 srednie 23202 1155. 392 ## 2 podstawowe 6851 1251. 403 ## 3 &lt;NA&gt; 1857 1527. 568 ## 4 wyzsze 13301 1758. 577 3.10 czenie zbiorów W celu zaprezentowania funkcji czcych dane przygotujemy kilka zbiorów pomocniczych: praca_czas &lt;- bank %&gt;% group_by(praca) %&gt;% summarise(sr_czas=mean(czas)) praca_saldo &lt;- bank %&gt;% group_by(praca) %&gt;% summarise(sr_saldo=mean(saldo)) zawod_saldo &lt;- bank %&gt;% rename(zawod=praca) %&gt;% group_by(zawod) %&gt;% summarise(sr_saldo=mean(saldo)) Do czenia dwóch zbiorów danych suy funkcja inner_join(), która jako argumenty przyjmuje nazwy zbiorów danych oraz klucz czenia. Jeli w obu zbiorach wystpuj kolumny o takich samych nazwach to zostan potraktowane jako klucz czenia: praca_czas_saldo &lt;- inner_join(praca_czas, praca_saldo) ## Joining, by = &quot;praca&quot; Jeli takie kolumny nie bd istniay to wywoanie funkcji zwróci bd: praca_czas_saldo &lt;- inner_join(praca_czas, zawod_saldo) ## Error: `by` must be supplied when `x` and `y` have no common variables. ## i use by = character()` to perform a cross-join. W takich przypadku naley wskaza klucz poczenia w postaci by = c(\"id1\"=\"id2\"): praca_czas_saldo &lt;- inner_join(praca_czas, zawod_saldo, by=c(&quot;praca&quot;=&quot;zawod&quot;)) Jeli w jednym ze zbiorów nie ma wszystkich identyfikatorów, które znajduj si w drugim zbiorze to zastosowanie funkcji inner_join() bdzie skutkowao zbiorem, w którym znajd si tylko te obserwacje, które udao si poczy. praca_saldo_1500 &lt;- praca_saldo %&gt;% filter(sr_saldo &gt; 1500) inner_join(praca_czas, praca_saldo_1500, by=&quot;praca&quot;) ## # A tibble: 6 x 3 ## praca sr_czas sr_saldo ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 289. 1522. ## 2 3 254. 1764. ## 3 5 256. 1521. ## 4 7 268. 1648. ## 5 8 287. 1984. ## 6 NA 238. 1772. Jeli chcemy pozostawi niedopasowane obserwacje to naley wykorzysta jedn z funkcji - left_join() lub right_join() w zalenoci od tego dla którego zbioru chcemy pozostawi wszystkie informacje. left_join(praca_czas, praca_saldo_1500, by=&quot;praca&quot;) ## # A tibble: 11 x 3 ## praca sr_czas sr_saldo ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 247. NA ## 2 2 289. 1522. ## 3 3 254. 1764. ## 4 4 246. NA ## 5 5 256. 1521. ## 6 6 263. NA ## 7 7 268. 1648. ## 8 8 287. 1984. ## 9 9 253. NA ## 10 10 257. NA ## 11 NA 238. 1772. 3.11 Szeroka i wska reprezentacja danych Do wyjanienia kwestii szerokiej i wskiej reprezentacji danych posuymy si danymi z GUS dotyczcymi przecitnego miesicznego spoycie wybranych artykuów ywnociowych na 1 osob w 2016 roku - plik. spozycie &lt;- read_xlsx(&quot;data/spozycie.xlsx&quot;) Taka tabela jest przykadem szerokiej reprezentacji danych. Z kolei w niektórych sytuacjach wygodnie jest korzysta z wskiej reprezentacji danych, a niektóre pakiety wrcz wymagaj takich zbiorów wejciowych. Do transformacji danych z reprezentacji szerokiej na wsk suy funkcja gather() (pol. gromadzi). Kluczowe s w niej dwa argumenty - pierwszy (key) okrela nazw nowej kolumny, która bdzie zawieraa nazwy zmiennych, a drugi (value) okrela nazw nowej kolumny, która bdzie zawieraa wartoci zmiennych. Jako kolejne argumenty podaje si nazwy kolumn, które maj by transformowane lub nazwy kolumn ze znakiem minus -, które nie maj by transformowane. spozycie_waskie &lt;- spozycie %&gt;% gather(artykul, spozycie, mieso, owoce, warzywa) # spozycie_waskie &lt;- spozycie %&gt;% # gather(artykul, spozycie, -kod, -nazwa) W takiej formie atwiej podsumowa dane: spozycie_waskie %&gt;% group_by(artykul) %&gt;% summarise(sr_spozycie=mean(spozycie)) ## # A tibble: 3 x 2 ## artykul sr_spozycie ## &lt;chr&gt; &lt;dbl&gt; ## 1 mieso 5.47 ## 2 owoce 3.65 ## 3 warzywa 8.85 W porównaniu do szerokiej reprezentacji danych: spozycie %&gt;% summarise(sr_spozycie_mieso=mean(mieso), sr_spozycie_owoce=mean(owoce), sr_spozycie_warzywa=mean(warzywa)) ## # A tibble: 1 x 3 ## sr_spozycie_mieso sr_spozycie_owoce sr_spozycie_warzywa ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.47 3.65 8.85 Transformacja z wskiej do szerokiej reprezentacji danych jest moliwa z zastosowaniem funkcji spread() (pol. rozprzestrzenia). W przypadku tej funkcji niezbdne s dwa argumenty - pierwszy (key) wskazuje kolumn zawierajc nazwy dla nowych zmiennych, a drugi argument (value) wskazuje kolumn zawierajc wartoci dla nowych zmiennych. spozycie_szerokie &lt;- spozycie_waskie %&gt;% spread(artykul, spozycie) 3.12 Eksport danych Zapis zbioru danych do zewntrznego pliku jest moliwy z wykorzystaniem funkcji write.table(). Jako argumenty tej funkcji okrelamy: zbiór danych (x), docelowe miejsce na dysku i nazw pliku (file), separator kolumn (sep), separator miejsc dziesitnych (dec) oraz argument row.names = FALSE, dziki któremu unikniemy dodatkowych numerów wierszy. write.table(spozycie_waskie, file = &quot;data/spozycie_w.csv&quot;, sep=&quot;;&quot;, dec=&quot;,&quot;, row.names=F) Taki plik jest plikiem csv, który moemy otworzy w Excelu i zapisa go z rozszerzeniem .xlsx. Teoretycznie istnieje pakiet xlsx, który umoliwia zapisywanie zbiorów od razu do Excela, ale dziaa w oparciu o Jav, co bywa problematyczne. 3.13 Zadania Na podstawie zbioru rossmann odpowied na pytania: Ile byo sklepów o asortymencie rozszerzonym w dniu 25-02-2014? W jaki dzie tygodnia rednia liczba klientów bya najwiksza w sklepie nr 101? Sklep jakiego typu charakteryzuje si najwiksz median sprzeday? Czy w cigu roku odlego do najbliszego sklepu konkurencji zmienia si dla jakiegokolwiek sklepu Rossmann? 3.14 Case study Rozwamy sklepy Rossmann, które w 2014 roku byy otwarte powyej 300 dni w roku. Czy rednia sprzeda wyraona w z w sklepach Rossmann róni si statystycznie pomidzy grupami zdefiniowanymi przez asortyment sklepu? Dane na temat redniego kursu miesicznego euro pobierz ze stron NBP. "],["wizualizacja-danych.html", "4 Wizualizacja danych 4.1 Wprowadzenie 4.2 Wykres punktowy 4.3 Histogram 4.4 Wykres pudekowy 4.5 Wykres supkowy 4.6 Wykres kafelkowy 4.7 Uwzgldnienie czasu 4.8 Facets 4.9 Wykres interaktywny", " 4 Wizualizacja danych Prezentacja 4.1 Wprowadzenie Przewodnik po wizualizacji danych Fundamentals of Data Visualization Bdziemy dziaa na zbiorze dotyczcym sprzeday w sklepach: rossmann.xlsx i rossmann.RData. library(tidyverse) # library(readxl) # # rossmann &lt;- read_xlsx(&quot;data/rossmann.xlsx&quot;) # # save(rossmann, file=&quot;data/rossmann.RData&quot;) # natywny format, mniejszy rozmiar, szybsze wczytywanie load(&quot;data/rossmann.RData&quot;) sklep77 &lt;- rossmann %&gt;% filter(sklep_id==77, czy_otwarty==&quot;Tak&quot;) Do prostych wykresów mona wykorzysta wbudowan funkcj plot. plot(sklep77$sprzedaz, sklep77$liczba_klientow, xlab = &quot;Sprzeda&quot;, ylab = &quot;Liczba klientów&quot;, main = &quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) Jej moliwoci s jednak ograniczone i stworzenie bardziej zaawansowanych grafik bdzie wymagajce. Wiodcym pakietem do wizualizacji danych w R jest ggplot2: dokumentacja: https://ggplot2.tidyverse.org/ cheatsheet tworzenie wykresów poprzez dodawanie (+) kolejnych warstw 4.2 Wykres punktowy Ten sam wykres co wczeniej, ale z wykorzystaniem pakietu ggplot2. Wykonanie krok po kroku: Utworzenie siatki - okrelenie co chcemy na wykresie przedstawi ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) W zalenoci od typu wykresu w funkcji aes mog znale si argumenty: x y fill size color shape Okrelenie w jaki sposób chcemy te dane przedstawi - funkcja zawsze zaczyna si od geom_: ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) + geom_point() Edytowanie etykiet osi - funkcje xlab i ylab: ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) + geom_point() + xlab(&quot;Sprzeda&quot;) + ylab(&quot;Liczba klientów&quot;) Dodanie tytuu - funkcja ggtitle ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) + geom_point() + xlab(&quot;Sprzeda&quot;) + ylab(&quot;Liczba klientów&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) Zmiana motywu - funkcja rozpoczynajca si od theme_: ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow)) + geom_point() + xlab(&quot;Sprzeda&quot;) + ylab(&quot;Liczba klientów&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() Dostpne motywy: theme_bw theme_classic theme_dark theme_gray theme_light theme_linedraw theme_minimal theme_void Powysze motywy s zaimplementowane w pakiecie ggplot2, ale mona take skorzysta z dodatkowych pakietów: theme_bbc theme_xkcd Albo stworzy swój wasny motyw. Zadanie Zmie motyw wykresu na wybrany przez siebie. Dodamy teraz do wykresu kolejn cech - rozpoczcie promocji, eby sprawdzi czy istnieje jaka tendencja. ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) + geom_point() + xlab(&quot;Sprzeda&quot;) + ylab(&quot;Liczba klientów&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() Okazuje si dosy interesujco, niemniej nazwa etykiety legendy nie wyglda zbyt dobrze. eby to poprawi musimy uy funkcji scale_ ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) + geom_point() + xlab(&quot;Sprzeda&quot;) + ylab(&quot;Liczba klientów&quot;) + scale_color_discrete(name = &quot;Promocja&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() W funkcji scale_ musimy poda w jaki sposób dan cech wizualizujemy (x/y/color/) oraz jakiego jest typu. Oprócz nazwy w tej funkcji moemy okreli wiele innych kwestii takich jak: wywietlane etykiety pocztek i koniec osi kolory wariantów etykiety wariantów ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) + geom_point() + scale_x_continuous(name = &quot;Sprzeda&quot;) + scale_y_continuous(name = &quot;Liczba klientów&quot;) + scale_color_discrete(name = &quot;Promocja&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() Zmiana pozycji legendy moliwa jest z wykorzystaniem funkcji theme: ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) + geom_point() + scale_x_continuous(name = &quot;Sprzeda&quot;) + scale_y_continuous(name = &quot;Liczba klientów&quot;) + scale_color_discrete(name = &quot;Promocja&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() + theme(legend.position = &quot;bottom&quot;) ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + scale_x_continuous(name = &quot;Sprzeda&quot;) + scale_y_continuous(name = &quot;Liczba klientów&quot;) + scale_color_discrete(name = &quot;Promocja&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() + theme(legend.position = &quot;bottom&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; 4.3 Histogram Rozkad cechy mona oceni na podstawie histogramu - domylnie rysowanych jest 30 supków. ggplot(data = sklep77, aes(x=sprzedaz)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. W funkcji geom_histogram mona poda liczb supków (bins) albo ich szeroko (binwidth). Poniej zastosowano supki o szerokoci 1000 euro. ggplot(data = sklep77, aes(x=sprzedaz)) + geom_histogram(binwidth = 1000) Dodatkowo w tej funkcji mona okreli kwestie estetyczne - kolory obramowania i wypenienia supków. ggplot(data = sklep77, aes(x=sprzedaz)) + geom_histogram(binwidth = 500, color = &quot;black&quot;, fill = &quot;green&quot;) Pena lista nazw kolorów znajduje si tutaj. Z wykorzystaniem funkcji scale_ zmieniamy nazwy osi (name), granice (limits) oraz wskazania liczbowe (breaks). Te dwie ostatnie wartoci musimy deklarowa jako wektory z wykorzystaniem funkcji c(). ggplot(data = sklep77, aes(x=sprzedaz)) + geom_histogram(binwidth = 500, color = &quot;black&quot;, fill = &quot;green&quot;) + scale_x_continuous(name = &quot;Sprzeda&quot;, limits = c(4000,17000), breaks = c(5000, 8000, 11000)) + scale_y_continuous(name = &quot;Liczebno&quot;, limits = c(0,50)) ## Warning: Removed 2 rows containing missing values (geom_bar). Mona zaumatyzowa proces dobierania wskaza liczbowych z wykorzystaniem funkcji seq opisanej szerzej w rozdziale 2.1.2. ggplot(data = sklep77, aes(x=sprzedaz)) + geom_histogram(binwidth = 500, color = &quot;black&quot;, fill = &quot;green&quot;) + scale_x_continuous(name = &quot;Sprzeda&quot;, limits = c(4000,17000), breaks = seq(4000, 17000, 1500)) + scale_y_continuous(name = &quot;Liczebno&quot;, limits = c(0,50)) ## Warning: Removed 2 rows containing missing values (geom_bar). 4.4 Wykres pudekowy Wykres pudekowy umoliwia porównywanie rozkadów cechy wg zmiennej grupujcej. Wymogiem jest aby na osi x znajdowaa si zmienna grupujca, a na osi y cecha analizowana. Przeanalizujemy sprzeda wedug kolejnych dni tygodnia. ggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot() ## Warning: Continuous x aesthetic -- did you forget aes(group=...)? Zdecydowanie nie jest wykres jakiego oczekiwalimy. Wynika to z faktu, e dzie tygodnia w zbiorze danych jest zapisany jako zmienna numeryczna, natomiast prawidowym typem dla zmiennej grupujcej jest typ tekstowy lub czynnik (faktor). Ten typ danych zosta szczegóowo opisany w czci 2.3. Dokonujemy zatem zamiany typu danych: sklep77 &lt;- sklep77 %&gt;% mutate(dzien_tyg=factor(x = dzien_tyg, levels = 1:6, labels = c(&quot;Pon&quot;, &quot;Wt&quot;, &quot;r&quot;, &quot;Czw&quot;, &quot;Pt&quot;, &quot;Sob&quot;), ordered = TRUE)) ggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot() Z tego wykresu mona ju odczyta, e najwysza mediana sprzeday wystpuje w poniedziaek, a najnisza w rod. Jeli kategorii jest duo to mona obróci wykres z wykorzystaniem funkcji coord_flip. ggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot() + coord_flip() Uycie tej funkcji powoduje wycznie obrócenie wykresu. Nazwy osi nie ulegy zmianie pomimo, e zostay zamienione. Odwrócimy jeszcze kolejno etykiet dnia tygodnia, tak aby na górze by poniedziaek. ggplot(sklep77, aes(x=dzien_tyg, y=sprzedaz)) + geom_boxplot() + coord_flip() + scale_x_discrete(limits = rev(levels(sklep77$dzien_tyg))) 4.5 Wykres supkowy W zalenoci od typu danych wejciowych, wykres supkowy mona stworzy na dwa sposoby: dane jednostkowe - geom_bar - funkcja sama oblicza wartoci do wywietlenia, dane zagregowane - geom_col - funkcja otrzymuje ju obliczone wartoci. Sprawdmy ile jest sklepów o danym asortymencie. W tym celu potrzebujemy informacj o sklepie i typie oferowanego asortymentu. rossmann_asort &lt;- rossmann %&gt;% select(sklep_id, sklep_asort) %&gt;% distinct() glimpse(rossmann_asort) ## Rows: 1,115 ## Columns: 2 ## $ sklep_id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18,~ ## $ sklep_asort &lt;chr&gt; &quot;Podstawowy&quot;, &quot;Podstawowy&quot;, &quot;Podstawowy&quot;, &quot;Rozszerzony&quot;, &quot;~ W funkcji aes podajemy tylko kolumn zawierajc dane do zliczenia. ggplot(rossmann_asort, aes(x=sklep_asort)) + geom_bar() Natomiast uycie funkcji geom_col wymaga samodzielnego obliczenia wartoci: rossmann_asort2 &lt;- rossmann_asort %&gt;% count(sklep_asort) glimpse(rossmann_asort2) ## Rows: 3 ## Columns: 2 ## $ sklep_asort &lt;chr&gt; &quot;Extra&quot;, &quot;Podstawowy&quot;, &quot;Rozszerzony&quot; ## $ n &lt;int&gt; 9, 593, 513 Warto do wywietlenia podajemy w funkcji aes w argumencie y. ggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) + geom_col() Uporzdkujemy etykiety osi x (obecnie s wywietlane w kolejnoci alfabetycznej) tworzc czynnik. rossmann_asort2 &lt;- rossmann_asort2 %&gt;% mutate(sklep_asort=factor(x = sklep_asort, levels = c(&quot;Podstawowy&quot;, &quot;Rozszerzony&quot;, &quot;Extra&quot;), ordered = T)) glimpse(rossmann_asort2) ## Rows: 3 ## Columns: 2 ## $ sklep_asort &lt;ord&gt; Extra, Podstawowy, Rozszerzony ## $ n &lt;int&gt; 9, 593, 513 ggplot(rossmann_asort2, aes(x=sklep_asort, y=n)) + geom_col() Do wykresu supkowego moemy doda jeszcze jedn zmienn. W tym przypadku bdzie to typ sklepu. rossmann_asort3 &lt;- rossmann %&gt;% select(sklep_id, sklep_asort, sklep_typ) %&gt;% distinct() %&gt;% count(sklep_asort, sklep_typ) %&gt;% mutate(sklep_asort=factor(x = sklep_asort, levels = c(&quot;Podstawowy&quot;, &quot;Rozszerzony&quot;, &quot;Extra&quot;), ordered = T)) glimpse(rossmann_asort3) ## Rows: 9 ## Columns: 3 ## $ sklep_asort &lt;ord&gt; Extra, Podstawowy, Podstawowy, Podstawowy, Podstawowy, Roz~ ## $ sklep_typ &lt;chr&gt; &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ## $ n &lt;int&gt; 9, 381, 7, 77, 128, 221, 1, 71, 220 Uwzgldnienie kolejnej zmiennej jest moliwe jako argument fill w funkcji aes. ggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) + geom_col() Domylnie kategorie s ukadane jedna na drug - stack. Mona je uoy obok siebie dodajc argument position = \"dodge\" w funkcji geom_col. ggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) + geom_col(position = &quot;dodge&quot;) Moemy jeszcze doda etykiety supków wykorzystujc funkcj geom_text, w której trzeba poda argumenty definujce pooenie wartoci etykiet. Wartoci tych argumentów bd zaleay od typu wykresu. ggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) + geom_col(position = &quot;dodge&quot;) + geom_text(aes(label = n), position = position_dodge(width = 0.9), vjust = -0.3) Zmienimy jeszcze nazw legendy za pomoc funkcji scale_fill_discrete. Wykorzystujemy t konkretn funkcj ze wzgldu na to, e typ sklepu jest argumentem fill w funkcji aes oraz cech jakociow (discrete). ggplot(rossmann_asort3, aes(x=sklep_asort, y=n, fill=sklep_typ)) + geom_col(position = &quot;dodge&quot;) + geom_text(aes(label = n), position = position_dodge(width = 0.9), vjust = -0.3) + scale_fill_discrete(name = &quot;Typ sklepu&quot;) 4.6 Wykres kafelkowy Do wizualizacji tabeli czstoci mona uy wykresu kafelkowego. W tym celu najpierw zliczamy wystpienia wariantów cech czy_promocja oraz czy_swieto_szkolne i wynik przekazujemy bezporednio do funkcji ggplot(). sklep77 %&gt;% count(czy_promocja, czy_swieto_szkolne) %&gt;% ggplot(aes(x = czy_promocja, y = czy_swieto_szkolne, fill = n)) + geom_tile() Aby doda do tego wykresu etykiety posuymy si funkcj geom_label() sklep77 %&gt;% count(czy_promocja, czy_swieto_szkolne) %&gt;% ggplot(aes(x = czy_promocja, y = czy_swieto_szkolne, fill = n)) + geom_tile() + geom_label(aes(label = n), color = &quot;white&quot;) Zwykle patrzc na wykres podwiadomie zakadamy, e ciemniejszy kolor oznacza wysze wartoci, natomiast jasny mae liczby. W tym przypadku ukad kolorów jest odwrócony. Musimy odpowiednio dobra kolory, aby to poprawi. Bardzo przydatne narzdzie znajduje si pod adresem: http://colorbrewer2.org/. Nastpnie korzystamy z funkcji scale_fill_gradient, w której okrelamy tylko kolor pocztkowy i kocowy. sklep77 %&gt;% count(czy_promocja, czy_swieto_szkolne) %&gt;% ggplot(., aes(x = czy_promocja, y = czy_swieto_szkolne, fill = n)) + geom_tile() + geom_label(aes(label = n), color = &quot;white&quot;) + scale_fill_gradient(low = &quot;#66c2a4&quot;, high = &quot;#005824&quot;) 4.7 Uwzgldnienie czasu Próba stworzenia wykresu przedstawiajcego zmian sprzeday w czasie za pomoc oryginalnych danych spowoduje uzsykanie niezbyt czytelnej grafiki. ggplot(sklep77, aes(x=data, y=sprzedaz, color=dzien_tyg)) + geom_point() Wynika to z faktu, e dzien tygodnia jest traktowany jak zmienna numeryczna, a data jest zmienn tekstow. Konwersja tekstu na dat jest moliwa z wykorzystaniem pakietu lubridate. W tym pakiecie kada cz daty ma swój akronim, który póniej jest wykorzystywany w odpowiednich funkcjach: y - rok (year) m - miesic (month) d - dzie (day) h - godzina (hour) m - minuta (minute) Przykady funkcji: ymd - konwertuje tekst zapisany w postaci rok-miesic-dzie na obiekt daty dmy_hm - konwertuje tekst zapisany w postaci dzie-miesic-rok godzina:minuta na obiekt daty month - pobiera z obiektu daty informacj o miesicu year - pobiera z obiektu daty informacj o roku week - pobiera z obiektu daty informacj o tygodniu roku Wedug powyszych regu korzystamy z funkcji ymd() do konwersji daty w naszym zbiorze. library(lubridate) sklep77a &lt;- sklep77 %&gt;% mutate(dzien_tyg=as.factor(dzien_tyg), data=ymd(data)) ggplot(sklep77a, aes(x=data, y=sprzedaz, color=dzien_tyg)) + geom_point() 4.8 Facets sr_sprzedaz &lt;- rossmann %&gt;% filter(sprzedaz &gt; 0) %&gt;% group_by(sklep_id, sklep_asort) %&gt;% summarise(sprzedaz_sr=mean(sprzedaz)) ## `summarise()` has grouped output by &#39;sklep_id&#39;. You can override using the `.groups` argument. odleglosc &lt;- rossmann %&gt;% select(sklep_id, sklep_konkurencja) %&gt;% distinct() sprzedaz_odleglosc &lt;- inner_join(sr_sprzedaz, odleglosc, by=&quot;sklep_id&quot;) ggplot(sprzedaz_odleglosc, aes(x=sprzedaz_sr, y=sklep_konkurencja)) + geom_point() + facet_wrap(~ sklep_asort) ## Warning: Removed 3 rows containing missing values (geom_point). sr_sprzedaz_prom &lt;- rossmann %&gt;% filter(sprzedaz &gt; 0) %&gt;% group_by(sklep_id, czy_promocja) %&gt;% summarise(sprzedaz_sr=mean(sprzedaz)) ## `summarise()` has grouped output by &#39;sklep_id&#39;. You can override using the `.groups` argument. sprzedaz_prom_odl &lt;- inner_join(sr_sprzedaz_prom, odleglosc) ## Joining, by = &quot;sklep_id&quot; head(sprzedaz_prom_odl) ## # A tibble: 6 x 4 ## # Groups: sklep_id [3] ## sklep_id czy_promocja sprzedaz_sr sklep_konkurencja ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Nie 4288. 1270 ## 2 1 Tak 5274. 1270 ## 3 2 Nie 3902. 570 ## 4 2 Tak 6295. 570 ## 5 3 Nie 5286. 14130 ## 6 3 Tak 8790. 14130 ggplot(sprzedaz_prom_odl, aes(x=sprzedaz_sr, y=sklep_konkurencja, color=czy_promocja)) + geom_point() ## Warning: Removed 6 rows containing missing values (geom_point). Zamiana reprezentacji danych na szerok. sprzedaz_prom_odl_wide &lt;- sprzedaz_prom_odl %&gt;% spread(czy_promocja, sprzedaz_sr) head(sprzedaz_prom_odl_wide) ## # A tibble: 6 x 4 ## # Groups: sklep_id [6] ## sklep_id sklep_konkurencja Nie Tak ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1270 4288. 5274. ## 2 2 570 3902. 6295. ## 3 3 14130 5286. 8790. ## 4 4 620 9030. 10686. ## 5 5 29910 3473. 6084. ## 6 6 310 4189. 6295. I na wsk. sprzedaz_prom_odl_long &lt;- sprzedaz_prom_odl_wide %&gt;% gather(czy_promocja, sprzedaz_sr, Nie, Tak) head(sprzedaz_prom_odl_long) ## # A tibble: 6 x 4 ## # Groups: sklep_id [6] ## sklep_id sklep_konkurencja czy_promocja sprzedaz_sr ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 1270 Nie 4288. ## 2 2 570 Nie 3902. ## 3 3 14130 Nie 5286. ## 4 4 620 Nie 9030. ## 5 5 29910 Nie 3473. ## 6 6 310 Nie 4189. 4.9 Wykres interaktywny Za pomoc pakietu plotly w prosty sposób mona zamieni statystyczny wykres ggplot na interaktywny. library(plotly) p &lt;- ggplot(data = sklep77, aes(x=sprzedaz, y=liczba_klientow, color=czy_promocja)) + geom_point() + scale_x_continuous(name = &quot;Sprzeda&quot;) + scale_y_continuous(name = &quot;Liczba klientów&quot;) + scale_color_discrete(name = &quot;Promocja&quot;) + ggtitle(&quot;Sprzeda i liczba klientów w sklepie Rossmann nr 77&quot;) + theme_light() + theme(legend.position = &quot;bottom&quot;) plotly::ggplotly(p) Zadanie Stwórz trzy grafiki dla danych dotyczcych filmów. filmy &lt;- read.csv(&quot;data/movies.csv&quot;) summary(filmy) ## title genre director year ## Length:2961 Length:2961 Length:2961 Min. :1920 ## Class :character Class :character Class :character 1st Qu.:1999 ## Mode :character Mode :character Mode :character Median :2004 ## Mean :2003 ## 3rd Qu.:2010 ## Max. :2016 ## duration gross budget cast_facebook_likes ## Min. : 37.0 Min. : 703 Min. : 218 Min. : 0 ## 1st Qu.: 95.0 1st Qu.: 12276810 1st Qu.: 11000000 1st Qu.: 2241 ## Median :106.0 Median : 34703228 Median : 26000000 Median : 4604 ## Mean :109.6 Mean : 58090401 Mean : 40619384 Mean : 12394 ## 3rd Qu.:119.0 3rd Qu.: 75590286 3rd Qu.: 55000000 3rd Qu.: 16926 ## Max. :330.0 Max. :760505847 Max. :300000000 Max. :656730 ## votes reviews rating ## Min. : 5 Min. : 2.0 Min. :1.600 ## 1st Qu.: 19918 1st Qu.: 199.0 1st Qu.:5.800 ## Median : 55749 Median : 364.0 Median :6.500 ## Mean : 109308 Mean : 503.3 Mean :6.389 ## 3rd Qu.: 133348 3rd Qu.: 631.0 3rd Qu.:7.100 ## Max. :1689764 Max. :5312.0 Max. :9.300 Z racji mnogoci gatunków mona ograniczy si do kilku wybranych. "],["programowanie-w-r.html", "5 Programowanie w R 5.1 Instrukcje warunkowe 5.2 Funkcje 5.3 Ptle", " 5 Programowanie w R Prezentacja 5.1 Instrukcje warunkowe Za pomoc instrukcji if moemy warunkowo wykonywa kod. Ogólna posta jest nastpujca: if(warunek){ # kod wykonany jeli warunek jest równy TRUE } else if(warunek) { # kod wykonany jeli warunek jest równy TRUE } else { # kod wykonany jeli warunek jest równy FALSE } Element warunek musi zwraca warto logiczn TRUE albo FALSE. Chc uwzgldni wicej ni jeden warunek naley wykorzysta odpowiedni operator czenia: i : &amp;&amp; lub : || 5.2 Funkcje Funkcj ograniczaj potrzeb kopiowania kodu i uatwiaj wprowadzanie zmian. Stworzenie funkcji wymaga: wymylenia nazwy funkcji, okrelenia elementów wejciowych, umieszczenia kodu w ciele funkcji. Istniej pewne dobre praktyki tworzenia funkcji: nazwy funkcji powinny by czasownikami, podkrelnik vs. notacja camelCase i konsekwencja stosowania, wspólny przedrostek np. rnorm, runif. 5.3 Ptle Ptl s wykorzystywane w sytuacji, w której chcemy powtórzy wykonanie kodu. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
